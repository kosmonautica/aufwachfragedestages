<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests - Aufwachfrage</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .test-case {
            margin: 15px 0;
            padding: 10px;
            border-left: 4px solid #ddd;
        }
        .test-case.pass {
            border-left-color: #4caf50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #fef1f0;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .test-message {
            color: #666;
            font-size: 0.9em;
        }
        .summary {
            margin-top: 30px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 4px;
            font-weight: bold;
        }
        .error-details {
            color: #d32f2f;
            font-size: 0.85em;
            margin-top: 5px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Unit Tests - Aufwachfrage</h1>
        <div id="test-results"></div>
        <div id="summary" class="summary"></div>
    </div>

    <script>
        // Test framework
        const results = [];

        function assert(condition, testName, message) {
            const passed = condition;
            results.push({ passed, testName, message });

            const resultDiv = document.createElement('div');
            resultDiv.className = `test-case ${passed ? 'pass' : 'fail'}`;
            resultDiv.innerHTML = `
                <div class="test-name">${passed ? '✓' : '✗'} ${testName}</div>
                <div class="test-message">${message}</div>
            `;
            document.getElementById('test-results').appendChild(resultDiv);
        }

        function assertEquals(actual, expected, testName) {
            const passed = actual === expected;
            const message = passed
                ? `Expected: ${expected}`
                : `Expected: ${expected}, Got: ${actual}`;
            assert(passed, testName, message);
        }

        function assertNotNull(value, testName) {
            assert(value !== null && value !== undefined, testName,
                value ? 'Value is defined' : 'Value is null/undefined');
        }

        function assertArrayLength(array, expectedLength, testName) {
            const passed = Array.isArray(array) && array.length === expectedLength;
            const message = passed
                ? `Array has ${expectedLength} items`
                : `Expected length ${expectedLength}, got ${array ? array.length : 'not an array'}`;
            assert(passed, testName, message);
        }

        // Mock Markdown content for testing
        const mockMarkdown = `# Aufwachfrage

Some description text here.

| Datum | Aufwachfrage | Thread on X/LinkedIn |
|-------|--------------|---------------------|
| 01.01.2024 | Was bedeutet Erfolg für dich? | [Link](https://example.com) |
| 02.01.2024 | What is your biggest fear? | [Link](https://example.com) |
| 03.01.2024 | Wie definierst du Glück? | [Link](https://example.com) |
| 04.01.2024 | Can you be truly happy? | [Link](https://example.com) |

More text here.`;

        // Copy of parseMarkdownTable function from script.js for testing
        function parseMarkdownTable(markdown) {
            const questions = [];
            const lines = markdown.split('\n');
            let inTable = false;

            for (let line of lines) {
                if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
                    if ((line.includes('Datum') || line.includes('Date')) && !line.match(/\d{2}\.\d{2}\.\d{4}/)) {
                        inTable = true;
                        continue;
                    }

                    if (line.includes('---')) {
                        continue;
                    }

                    if (inTable) {
                        const columns = line.split('|')
                            .map(col => col.trim())
                            .filter(col => col !== '');

                        if (columns.length >= 2) {
                            const date = columns[0];
                            const question = columns[1];

                            if (date && question) {
                                questions.push({ date, question });
                            }
                        }
                    }
                }
            }

            return questions;
        }

        // Run tests
        function runTests() {
            console.log('Running tests...');

            // Test 1: Parse Markdown Table
            const questions = parseMarkdownTable(mockMarkdown);
            assertNotNull(questions, 'Parse Markdown: Returns array');
            assertArrayLength(questions, 4, 'Parse Markdown: Correct number of questions');

            // Test 2: Exact wording preservation (German)
            const germanQuestion = questions.find(q => q.date === '01.01.2024');
            assertNotNull(germanQuestion, 'Find German question by date');
            assertEquals(
                germanQuestion.question,
                'Was bedeutet Erfolg für dich?',
                'German question: Exact wording preserved'
            );

            // Test 3: Exact wording preservation (English)
            const englishQuestion = questions.find(q => q.date === '02.01.2024');
            assertNotNull(englishQuestion, 'Find English question by date');
            assertEquals(
                englishQuestion.question,
                'What is your biggest fear?',
                'English question: Exact wording preserved'
            );

            // Test 4: No translation occurred
            const question3 = questions.find(q => q.date === '03.01.2024');
            assert(
                question3.question.includes('Glück') && !question3.question.includes('happiness'),
                'German word "Glück" not translated',
                'Verified German word remains in original language'
            );

            // Test 5: Date format preserved
            assert(
                questions.every(q => q.date.match(/\d{2}\.\d{2}\.\d{4}/)),
                'Date format preservation',
                'All dates maintain DD.MM.YYYY format'
            );

            // Test 6: No empty questions
            assert(
                questions.every(q => q.question.length > 0),
                'No empty questions',
                'All questions have content'
            );

            // Test 7: Special characters preserved
            const specialCharQuestion = questions.find(q => q.question.includes('?'));
            assertNotNull(specialCharQuestion, 'Special characters preserved');
            assert(
                questions.every(q => q.question.endsWith('?')),
                'Question marks preserved',
                'All questions end with "?"'
            );

            // Test 8: Mixed language support
            const hasGerman = questions.some(q => /[äöüß]/.test(q.question));
            const hasEnglish = questions.some(q => /^[A-Z]/.test(q.question) && !(/[äöüß]/.test(q.question)));
            assert(
                hasGerman && hasEnglish,
                'Mixed language support',
                'Both German and English questions detected'
            );

            // Test 9: Trimming works correctly
            assert(
                questions.every(q => q.question === q.question.trim()),
                'Questions are trimmed',
                'No leading/trailing whitespace'
            );

            // Test 10: Table structure validation
            const testInvalidMarkdown = '| Only | One |\n| Column | Here |';
            const invalidQuestions = parseMarkdownTable(testInvalidMarkdown);
            assert(
                invalidQuestions.length === 0,
                'Invalid table structure handling',
                'Parser correctly handles malformed tables'
            );

            // Test 11: Exact character preservation
            const originalText = 'Was bedeutet Erfolg für dich?';
            const parsedText = germanQuestion.question;
            assert(
                originalText === parsedText,
                'Character-by-character comparison',
                'Every character preserved exactly'
            );

            // Test 12: No encoding issues
            assert(
                questions.every(q => !q.question.includes('&uml;') && !q.question.includes('&#')),
                'No HTML entity encoding',
                'Special characters stored as plain text'
            );

            // ===== HISTORY-LANE TESTS =====

            // Copy of History-Lane functions for testing
            function getCurrentDayMonth_test() {
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                return `${day}.${month}`;
            }

            function filterQuestionsByDayMonth_test(questions, dayMonth) {
                return questions.filter(q => {
                    const dateParts = q.date.split('.');
                    if (dateParts.length >= 2) {
                        const questionDayMonth = `${dateParts[0]}.${dateParts[1]}`;
                        return questionDayMonth === dayMonth;
                    }
                    return false;
                });
            }

            function sortQuestionsDescending_test(questions) {
                return questions.sort((a, b) => {
                    const parseDate = (dateStr) => {
                        const parts = dateStr.split('.');
                        if (parts.length === 3) {
                            return new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
                        }
                        return new Date(0);
                    };
                    const dateA = parseDate(a.date);
                    const dateB = parseDate(b.date);
                    return dateB - dateA;
                });
            }

            function dateToDD_MM_test(date) {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                return `${day}.${month}`;
            }

            function dateToDD_MM_YYYY_test(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${day}.${month}.${year}`;
            }

            // Mock data for History-Lane tests
            const historyMockData = [
                { date: '07.01.2024', question: 'Question from 2024' },
                { date: '07.01.2023', question: 'Question from 2023' },
                { date: '07.01.2022', question: 'Question from 2022' },
                { date: '08.01.2024', question: 'Different day question' },
                { date: '07.02.2024', question: 'Different month question' },
                { date: '29.02.2020', question: 'Leap year question' }
            ];

            // Test 13: getCurrentDayMonth format
            const currentDayMonth = getCurrentDayMonth_test();
            assert(
                /^\d{2}\.\d{2}$/.test(currentDayMonth),
                'History-Lane: getCurrentDayMonth format',
                `Returns DD.MM format: ${currentDayMonth}`
            );

            // Test 14: Filter matching questions
            const filtered07_01 = filterQuestionsByDayMonth_test(historyMockData, '07.01');
            assert(
                filtered07_01.length === 3,
                'History-Lane: Filter matching questions',
                'Correctly filters 3 questions for 07.01'
            );

            // Test 15: Filter excludes non-matching
            const allMatching = filtered07_01.every(q => q.date.startsWith('07.01'));
            assert(
                allMatching,
                'History-Lane: Filter excludes non-matching',
                'All filtered questions match 07.01'
            );

            // Test 16: Filter with no matches
            const filtered99_99 = filterQuestionsByDayMonth_test(historyMockData, '99.99');
            assert(
                filtered99_99.length === 0,
                'History-Lane: Filter with no matches',
                'Returns empty array when no matches found'
            );

            // Test 17: Descending sort order
            const sorted = sortQuestionsDescending_test([...historyMockData]);
            const first = sorted[0].date;
            const last = sorted[sorted.length - 1].date;
            assert(
                first.includes('2024') && !last.includes('2024'),
                'History-Lane: Descending sort order',
                'Newest questions first (2024 before 2020)'
            );

            // Test 18: Sort with same year different months
            const sameYearData = [
                { date: '01.03.2024', question: 'March' },
                { date: '01.01.2024', question: 'January' }
            ];
            const sortedSameYear = sortQuestionsDescending_test([...sameYearData]);
            assert(
                sortedSameYear[0].date === '01.03.2024',
                'History-Lane: Sort same year different months',
                'March comes before January (descending)'
            );

            // Test 19: Leap year date handling
            const leapYearFiltered = filterQuestionsByDayMonth_test(historyMockData, '29.02');
            assert(
                leapYearFiltered.length === 1,
                'History-Lane: Leap year date handling',
                'Correctly handles February 29th'
            );

            // Test 20: Edge case - January 1st
            const edgeCaseData = [{ date: '01.01.2024', question: 'New Year' }];
            const edgeFiltered = filterQuestionsByDayMonth_test(edgeCaseData, '01.01');
            assert(
                edgeFiltered.length === 1,
                'History-Lane: Edge case January 1st',
                'Correctly handles 01.01'
            );

            // Test 21: Edge case - December 31st
            const dec31Data = [{ date: '31.12.2023', question: 'New Years Eve' }];
            const dec31Filtered = filterQuestionsByDayMonth_test(dec31Data, '31.12');
            assert(
                dec31Filtered.length === 1,
                'History-Lane: Edge case December 31st',
                'Correctly handles 31.12'
            );

            // Test 22: Multiple years same day/month
            const multiYear = filterQuestionsByDayMonth_test(historyMockData, '07.01');
            const years = multiYear.map(q => q.date.split('.')[2]);
            const uniqueYears = [...new Set(years)];
            assert(
                uniqueYears.length === 3,
                'History-Lane: Multiple years same day/month',
                'Correctly finds questions across 3 different years'
            );

            // Test 23: dateToDD_MM - Convert Date to DD.MM format
            const testDate1 = new Date('2024-01-07');
            const converted1 = dateToDD_MM_test(testDate1);
            assert(
                converted1 === '07.01',
                'History-Lane: dateToDD_MM basic conversion',
                `Converts 2024-01-07 to 07.01, got: ${converted1}`
            );

            // Test 24: dateToDD_MM - Single digit day/month padding
            const testDate2 = new Date('2024-03-05');
            const converted2 = dateToDD_MM_test(testDate2);
            assert(
                converted2 === '05.03',
                'History-Lane: dateToDD_MM with padding',
                `Single digits padded correctly: ${converted2}`
            );

            // Test 25: dateToDD_MM - December 31st
            const testDate3 = new Date('2023-12-31');
            const converted3 = dateToDD_MM_test(testDate3);
            assert(
                converted3 === '31.12',
                'History-Lane: dateToDD_MM edge case Dec 31',
                `Handles end of year correctly: ${converted3}`
            );

            // Test 26: Custom date filtering workflow
            const customDate = new Date('2024-01-07');
            const customDayMonth = dateToDD_MM_test(customDate);
            const customFiltered = filterQuestionsByDayMonth_test(historyMockData, customDayMonth);
            assert(
                customFiltered.length === 3,
                'History-Lane: Custom date filtering workflow',
                'Complete workflow from Date to filtered results works'
            );

            // Test 27: Reset to current date simulation
            const currentDate = new Date();
            const resetDayMonth = dateToDD_MM_test(currentDate);
            assert(
                /^\d{2}\.\d{2}$/.test(resetDayMonth),
                'History-Lane: Reset to current date format',
                `Reset produces valid DD.MM format: ${resetDayMonth}`
            );

            // Test 28: dateToDD_MM_YYYY basic conversion
            const testDateISO1 = new Date('2024-01-07');
            const convertedISO1 = dateToDD_MM_YYYY_test(testDateISO1);
            assert(
                convertedISO1 === '07.01.2024',
                'History-Lane: dateToDD_MM_YYYY basic conversion',
                `Converts to DD.MM.YYYY format: ${convertedISO1}`
            );

            // Test 29: dateToDD_MM_YYYY with single digit day/month
            const testDateISO2 = new Date('2024-03-05');
            const convertedISO2 = dateToDD_MM_YYYY_test(testDateISO2);
            assert(
                convertedISO2 === '05.03.2024',
                'History-Lane: dateToDD_MM_YYYY with padding',
                `Single digits padded in DD.MM.YYYY: ${convertedISO2}`
            );

            // Test 30: Navigation - Previous day
            const navDate1 = new Date('2024-01-15');
            const prevDay = new Date(navDate1);
            prevDay.setDate(prevDay.getDate() - 1);
            assert(
                prevDay.getDate() === 14,
                'History-Lane: Navigate to previous day',
                `Previous day from 15th is 14th`
            );

            // Test 31: Navigation - Next day
            const navDate2 = new Date('2024-01-15');
            const nextDayDate = new Date(navDate2);
            nextDayDate.setDate(nextDayDate.getDate() + 1);
            assert(
                nextDayDate.getDate() === 16,
                'History-Lane: Navigate to next day',
                `Next day from 15th is 16th`
            );

            // Test 32: Navigation - Month boundary (backward)
            const navDate3 = new Date('2024-02-01');
            const prevMonth = new Date(navDate3);
            prevMonth.setDate(prevMonth.getDate() - 1);
            assert(
                prevMonth.getDate() === 31 && prevMonth.getMonth() === 0,
                'History-Lane: Navigate backward across month boundary',
                `Previous day from Feb 1 is Jan 31`
            );

            // Test 33: Navigation - Month boundary (forward)
            const navDate4 = new Date('2024-01-31');
            const nextMonth = new Date(navDate4);
            nextMonth.setDate(nextMonth.getDate() + 1);
            assert(
                nextMonth.getDate() === 1 && nextMonth.getMonth() === 1,
                'History-Lane: Navigate forward across month boundary',
                `Next day from Jan 31 is Feb 1`
            );

            // Test 34: Parse DD.MM.YYYY format
            const testDateString = '07.01.2024';
            const [testDay, testMonth, testYear] = testDateString.split('.');
            const parsedDate = new Date(parseInt(testYear), parseInt(testMonth) - 1, parseInt(testDay));
            assert(
                parsedDate.getDate() === 7 && parsedDate.getMonth() === 0 && parsedDate.getFullYear() === 2024,
                'History-Lane: Parse DD.MM.YYYY string format',
                `Correctly parses 07.01.2024 to January 7, 2024`
            );

            // Test 35: Validate invalid date (31.02.2024)
            const invalidDateString = '31.02.2024';
            const [invDay, invMonth, invYear] = invalidDateString.split('.');
            const invalidDate = new Date(parseInt(invYear), parseInt(invMonth) - 1, parseInt(invDay));
            const isValidDate = invalidDate.getDate() === parseInt(invDay) &&
                                invalidDate.getMonth() === parseInt(invMonth) - 1 &&
                                invalidDate.getFullYear() === parseInt(invYear);
            assert(
                !isValidDate,
                'History-Lane: Validate invalid date detection',
                `31.02.2024 is correctly identified as invalid`
            );

            // Display summary
            const passed = results.filter(r => r.passed).length;
            const total = results.length;
            const percentage = Math.round((passed / total) * 100);

            document.getElementById('summary').innerHTML = `
                <div>Tests Completed: ${total}</div>
                <div style="color: ${passed === total ? '#2e7d32' : '#d32f2f'}">
                    Passed: ${passed} | Failed: ${total - passed} | Success Rate: ${percentage}%
                </div>
            `;

            if (passed === total) {
                console.log('✓ All tests passed!');
            } else {
                console.log(`✗ ${total - passed} test(s) failed`);
            }
        }

        // Run tests when page loads
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
