<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests - Aufwachfrage</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .test-case {
            margin: 15px 0;
            padding: 10px;
            border-left: 4px solid #ddd;
        }
        .test-case.pass {
            border-left-color: #4caf50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #fef1f0;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .test-message {
            color: #666;
            font-size: 0.9em;
        }
        .summary {
            margin-top: 30px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 4px;
            font-weight: bold;
        }
        .error-details {
            color: #d32f2f;
            font-size: 0.85em;
            margin-top: 5px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Unit Tests - Aufwachfrage</h1>
        <div id="test-results"></div>
        <div id="summary" class="summary"></div>
    </div>

    <script>
        // Test framework
        const results = [];

        function assert(condition, testName, message) {
            const passed = condition;
            results.push({ passed, testName, message });

            const resultDiv = document.createElement('div');
            resultDiv.className = `test-case ${passed ? 'pass' : 'fail'}`;
            resultDiv.innerHTML = `
                <div class="test-name">${passed ? '✓' : '✗'} ${testName}</div>
                <div class="test-message">${message}</div>
            `;
            document.getElementById('test-results').appendChild(resultDiv);
        }

        function assertEquals(actual, expected, testName) {
            const passed = actual === expected;
            const message = passed
                ? `Expected: ${expected}`
                : `Expected: ${expected}, Got: ${actual}`;
            assert(passed, testName, message);
        }

        function assertNotNull(value, testName) {
            assert(value !== null && value !== undefined, testName,
                value ? 'Value is defined' : 'Value is null/undefined');
        }

        function assertArrayLength(array, expectedLength, testName) {
            const passed = Array.isArray(array) && array.length === expectedLength;
            const message = passed
                ? `Array has ${expectedLength} items`
                : `Expected length ${expectedLength}, got ${array ? array.length : 'not an array'}`;
            assert(passed, testName, message);
        }

        // Mock Markdown content for testing
        const mockMarkdown = `# Aufwachfrage

Some description text here.

| Datum | Aufwachfrage | Thread on X/LinkedIn |
|-------|--------------|---------------------|
| 01.01.2024 | Was bedeutet Erfolg für dich? | [Link](https://example.com) |
| 02.01.2024 | What is your biggest fear? | [Link](https://example.com) |
| 03.01.2024 | Wie definierst du Glück? | [Link](https://example.com) |
| 04.01.2024 | Can you be truly happy? | [Link](https://example.com) |

More text here.`;

        // Copy of parseMarkdownTable function from script.js for testing
        function parseMarkdownTable(markdown) {
            const questions = [];
            const lines = markdown.split('\n');
            let inTable = false;

            for (let line of lines) {
                if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
                    if ((line.includes('Datum') || line.includes('Date')) && !line.match(/\d{2}\.\d{2}\.\d{4}/)) {
                        inTable = true;
                        continue;
                    }

                    if (line.includes('---')) {
                        continue;
                    }

                    if (inTable) {
                        const columns = line.split('|')
                            .map(col => col.trim())
                            .filter(col => col !== '');

                        if (columns.length >= 2) {
                            const date = columns[0];
                            const question = columns[1];

                            if (date && question) {
                                questions.push({ date, question });
                            }
                        }
                    }
                }
            }

            return questions;
        }

        // Run tests
        function runTests() {
            console.log('Running tests...');

            // Test 1: Parse Markdown Table
            const questions = parseMarkdownTable(mockMarkdown);
            assertNotNull(questions, 'Parse Markdown: Returns array');
            assertArrayLength(questions, 4, 'Parse Markdown: Correct number of questions');

            // Test 2: Exact wording preservation (German)
            const germanQuestion = questions.find(q => q.date === '01.01.2024');
            assertNotNull(germanQuestion, 'Find German question by date');
            assertEquals(
                germanQuestion.question,
                'Was bedeutet Erfolg für dich?',
                'German question: Exact wording preserved'
            );

            // Test 3: Exact wording preservation (English)
            const englishQuestion = questions.find(q => q.date === '02.01.2024');
            assertNotNull(englishQuestion, 'Find English question by date');
            assertEquals(
                englishQuestion.question,
                'What is your biggest fear?',
                'English question: Exact wording preserved'
            );

            // Test 4: No translation occurred
            const question3 = questions.find(q => q.date === '03.01.2024');
            assert(
                question3.question.includes('Glück') && !question3.question.includes('happiness'),
                'German word "Glück" not translated',
                'Verified German word remains in original language'
            );

            // Test 5: Date format preserved
            assert(
                questions.every(q => q.date.match(/\d{2}\.\d{2}\.\d{4}/)),
                'Date format preservation',
                'All dates maintain DD.MM.YYYY format'
            );

            // Test 6: No empty questions
            assert(
                questions.every(q => q.question.length > 0),
                'No empty questions',
                'All questions have content'
            );

            // Test 7: Special characters preserved
            const specialCharQuestion = questions.find(q => q.question.includes('?'));
            assertNotNull(specialCharQuestion, 'Special characters preserved');
            assert(
                questions.every(q => q.question.endsWith('?')),
                'Question marks preserved',
                'All questions end with "?"'
            );

            // Test 8: Mixed language support
            const hasGerman = questions.some(q => /[äöüß]/.test(q.question));
            const hasEnglish = questions.some(q => /^[A-Z]/.test(q.question) && !(/[äöüß]/.test(q.question)));
            assert(
                hasGerman && hasEnglish,
                'Mixed language support',
                'Both German and English questions detected'
            );

            // Test 9: Trimming works correctly
            assert(
                questions.every(q => q.question === q.question.trim()),
                'Questions are trimmed',
                'No leading/trailing whitespace'
            );

            // Test 10: Table structure validation
            const testInvalidMarkdown = '| Only | One |\n| Column | Here |';
            const invalidQuestions = parseMarkdownTable(testInvalidMarkdown);
            assert(
                invalidQuestions.length === 0,
                'Invalid table structure handling',
                'Parser correctly handles malformed tables'
            );

            // Test 11: Exact character preservation
            const originalText = 'Was bedeutet Erfolg für dich?';
            const parsedText = germanQuestion.question;
            assert(
                originalText === parsedText,
                'Character-by-character comparison',
                'Every character preserved exactly'
            );

            // Test 12: No encoding issues
            assert(
                questions.every(q => !q.question.includes('&uml;') && !q.question.includes('&#')),
                'No HTML entity encoding',
                'Special characters stored as plain text'
            );

            // ===== HISTORY-LANE TESTS =====

            // Copy of History-Lane functions for testing
            function getCurrentDayMonth_test() {
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                return `${day}.${month}`;
            }

            function filterQuestionsByDayMonth_test(questions, dayMonth) {
                return questions.filter(q => {
                    const dateParts = q.date.split('.');
                    if (dateParts.length >= 2) {
                        const questionDayMonth = `${dateParts[0]}.${dateParts[1]}`;
                        return questionDayMonth === dayMonth;
                    }
                    return false;
                });
            }

            function sortQuestionsDescending_test(questions) {
                return questions.sort((a, b) => {
                    const parseDate = (dateStr) => {
                        const parts = dateStr.split('.');
                        if (parts.length === 3) {
                            return new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
                        }
                        return new Date(0);
                    };
                    const dateA = parseDate(a.date);
                    const dateB = parseDate(b.date);
                    return dateB - dateA;
                });
            }

            // Mock data for History-Lane tests
            const historyMockData = [
                { date: '07.01.2024', question: 'Question from 2024' },
                { date: '07.01.2023', question: 'Question from 2023' },
                { date: '07.01.2022', question: 'Question from 2022' },
                { date: '08.01.2024', question: 'Different day question' },
                { date: '07.02.2024', question: 'Different month question' },
                { date: '29.02.2020', question: 'Leap year question' }
            ];

            // Test 13: getCurrentDayMonth format
            const currentDayMonth = getCurrentDayMonth_test();
            assert(
                /^\d{2}\.\d{2}$/.test(currentDayMonth),
                'History-Lane: getCurrentDayMonth format',
                `Returns DD.MM format: ${currentDayMonth}`
            );

            // Test 14: Filter matching questions
            const filtered07_01 = filterQuestionsByDayMonth_test(historyMockData, '07.01');
            assert(
                filtered07_01.length === 3,
                'History-Lane: Filter matching questions',
                'Correctly filters 3 questions for 07.01'
            );

            // Test 15: Filter excludes non-matching
            const allMatching = filtered07_01.every(q => q.date.startsWith('07.01'));
            assert(
                allMatching,
                'History-Lane: Filter excludes non-matching',
                'All filtered questions match 07.01'
            );

            // Test 16: Filter with no matches
            const filtered99_99 = filterQuestionsByDayMonth_test(historyMockData, '99.99');
            assert(
                filtered99_99.length === 0,
                'History-Lane: Filter with no matches',
                'Returns empty array when no matches found'
            );

            // Test 17: Descending sort order
            const sorted = sortQuestionsDescending_test([...historyMockData]);
            const first = sorted[0].date;
            const last = sorted[sorted.length - 1].date;
            assert(
                first.includes('2024') && !last.includes('2024'),
                'History-Lane: Descending sort order',
                'Newest questions first (2024 before 2020)'
            );

            // Test 18: Sort with same year different months
            const sameYearData = [
                { date: '01.03.2024', question: 'March' },
                { date: '01.01.2024', question: 'January' }
            ];
            const sortedSameYear = sortQuestionsDescending_test([...sameYearData]);
            assert(
                sortedSameYear[0].date === '01.03.2024',
                'History-Lane: Sort same year different months',
                'March comes before January (descending)'
            );

            // Test 19: Leap year date handling
            const leapYearFiltered = filterQuestionsByDayMonth_test(historyMockData, '29.02');
            assert(
                leapYearFiltered.length === 1,
                'History-Lane: Leap year date handling',
                'Correctly handles February 29th'
            );

            // Test 20: Edge case - January 1st
            const edgeCaseData = [{ date: '01.01.2024', question: 'New Year' }];
            const edgeFiltered = filterQuestionsByDayMonth_test(edgeCaseData, '01.01');
            assert(
                edgeFiltered.length === 1,
                'History-Lane: Edge case January 1st',
                'Correctly handles 01.01'
            );

            // Test 21: Edge case - December 31st
            const dec31Data = [{ date: '31.12.2023', question: 'New Years Eve' }];
            const dec31Filtered = filterQuestionsByDayMonth_test(dec31Data, '31.12');
            assert(
                dec31Filtered.length === 1,
                'History-Lane: Edge case December 31st',
                'Correctly handles 31.12'
            );

            // Test 22: Multiple years same day/month
            const multiYear = filterQuestionsByDayMonth_test(historyMockData, '07.01');
            const years = multiYear.map(q => q.date.split('.')[2]);
            const uniqueYears = [...new Set(years)];
            assert(
                uniqueYears.length === 3,
                'History-Lane: Multiple years same day/month',
                'Correctly finds questions across 3 different years'
            );

            // Display summary
            const passed = results.filter(r => r.passed).length;
            const total = results.length;
            const percentage = Math.round((passed / total) * 100);

            document.getElementById('summary').innerHTML = `
                <div>Tests Completed: ${total}</div>
                <div style="color: ${passed === total ? '#2e7d32' : '#d32f2f'}">
                    Passed: ${passed} | Failed: ${total - passed} | Success Rate: ${percentage}%
                </div>
            `;

            if (passed === total) {
                console.log('✓ All tests passed!');
            } else {
                console.log(`✗ ${total - passed} test(s) failed`);
            }
        }

        // Run tests when page loads
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
